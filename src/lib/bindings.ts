// @ts-nocheck
// Auto-generated by tauri-specta. DO NOT EDIT.

// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
  /**
   * Download a file from URL to local disk
   */
  async downloadFile(
    url: string,
    fileName: string | null,
    mediaType: string | null
  ): Promise<Result<string, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('download_file', { url, fileName, mediaType }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Cancel an active download by URL
   */
  async cancelDownload(url: string): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('cancel_download', { url }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Retry a failed download
   */
  async retryDownload(
    url: string,
    fileName: string | null,
    mediaType: string | null
  ): Promise<Result<string, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('retry_download', { url, fileName, mediaType }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Get all active downloads
   */
  async getDownloads(): Promise<DownloadState[]> {
    return await TAURI_INVOKE('get_downloads');
  },
  /**
   * Get all downloads from database
   */
  async getDownloadsFromDb(): Promise<Result<DownloadState[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_downloads_from_db') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Clears all local app data (database, preferences, reading state, recovery files).
   */
  async clearLocalData(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('clear_local_data') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Simple greeting command for demonstration purposes.
   */
  async greet(name: string): Promise<Result<string, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('greet', { name }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Loads user preferences from disk.
   * Returns default preferences if the file doesn't exist.
   */
  async loadPreferences(): Promise<Result<AppPreferences, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('load_preferences') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Saves user preferences to disk.
   * Uses atomic write (temp file + rename) to prevent corruption.
   */
  async savePreferences(preferences: AppPreferences): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('save_preferences', { preferences }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Loads the last reading entry from disk.
   * Returns None (as null in TypeScript) if the file doesn't exist.
   */
  async loadLastReading(): Promise<Result<LastReadingEntry | null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('load_last_reading') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Saves the last reading entry to disk.
   * Uses atomic write (temp file + rename) to prevent corruption.
   */
  async saveLastReading(entry: LastReadingEntry): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('save_last_reading', { entry }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Sends a native system notification.
   * On mobile platforms, returns an error as notifications are not yet supported.
   */
  async sendNativeNotification(title: string, body: string | null): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('send_native_notification', { title, body }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Saves emergency data to a JSON file for later recovery.
   * Validates filename and enforces a 10MB size limit.
   */
  async saveEmergencyData(filename: string, data: JsonValue): Promise<Result<null, RecoveryError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('save_emergency_data', { filename, data }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Loads emergency data from a previously saved JSON file.
   * Returns FileNotFound if the file doesn't exist.
   */
  async loadEmergencyData(filename: string): Promise<Result<JsonValue, RecoveryError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('load_emergency_data', { filename }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Removes recovery files older than 7 days.
   * Returns the count of removed files.
   */
  async cleanupOldRecoveryFiles(): Promise<Result<number, RecoveryError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('cleanup_old_recovery_files') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Shows the quick pane window and makes it the key window (for keyboard input).
   */
  async showQuickPane(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('show_quick_pane') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Dismisses the quick pane window.
   * On macOS, resigns key window status before hiding to avoid activating main window.
   */
  async dismissQuickPane(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('dismiss_quick_pane') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Toggles the quick pane window visibility.
   */
  async toggleQuickPane(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('toggle_quick_pane') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Returns the default shortcut constant for frontend use.
   */
  async getDefaultQuickPaneShortcut(): Promise<string> {
    return await TAURI_INVOKE('get_default_quick_pane_shortcut');
  },
  /**
   * Updates the global shortcut for the quick pane.
   * Pass None to reset to default.
   */
  async updateQuickPaneShortcut(shortcut: string | null): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('update_quick_pane_shortcut', { shortcut }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Show the main window (command exposed to frontend)
   */
  async trayShowWindow(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('tray_show_window') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Hide the main window (command exposed to frontend)
   */
  async trayHideWindow(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('tray_hide_window') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Update the tray icon state
   */
  async traySetIconState(state: TrayIconState): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('tray_set_icon_state', { state }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Update the tray tooltip
   */
  async traySetTooltip(tooltip: string): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('tray_set_tooltip', { tooltip }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Get the current tray icon state
   */
  async trayGetState(): Promise<TrayIconState> {
    return await TAURI_INVOKE('tray_get_state');
  },
  /**
   * Check if the main window is visible
   */
  async trayIsWindowVisible(): Promise<Result<boolean, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('tray_is_window_visible') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async saveMinifluxAccount(config: AuthConfig): Promise<Result<string, AccountError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('save_miniflux_account', { config }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getMinifluxAccounts(): Promise<Result<MinifluxConnection[], AccountError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_miniflux_accounts') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getActiveMinifluxAccount(): Promise<Result<MinifluxConnection | null, AccountError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_active_miniflux_account') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async switchMinifluxAccount(id: string): Promise<Result<null, AccountError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('switch_miniflux_account', { id }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async deleteMinifluxAccount(id: string): Promise<Result<null, AccountError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('delete_miniflux_account', { id }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async autoReconnectMiniflux(): Promise<Result<null, AccountError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('auto_reconnect_miniflux') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Connect to Miniflux server
   */
  async minifluxConnect(config: AuthConfig): Promise<Result<boolean, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('miniflux_connect', { config }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Disconnect from Miniflux server
   */
  async minifluxDisconnect(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('miniflux_disconnect') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Check if connected to Miniflux server
   */
  async minifluxIsConnected(): Promise<Result<boolean, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('miniflux_is_connected') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Get all categories
   */
  async getCategories(): Promise<Result<Category[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_categories') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Get all feeds
   */
  async getFeeds(): Promise<Result<Feed[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_feeds') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Get feeds by category
   */
  async getCategoryFeeds(categoryId: string): Promise<Result<Feed[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_category_feeds', { categoryId }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Get entries with filters
   */
  async getEntries(filters: EntryFilters): Promise<Result<EntryResponse, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_entries', { filters }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Get a single entry
   */
  async getEntry(entryId: string): Promise<Result<Entry, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_entry', { entryId }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Mark entry as read
   */
  async markEntryRead(id: string): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('mark_entry_read', { id }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Mark multiple entries as read
   */
  async markEntriesRead(ids: string[]): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('mark_entries_read', { ids }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Toggle entry star
   */
  async toggleEntryStar(id: string): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('toggle_entry_star', { id }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Update entry
   */
  async updateEntry(id: string, updates: EntryUpdate): Promise<Result<Entry, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('update_entry', { id, updates }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Refresh a feed
   */
  async refreshFeed(id: string): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('refresh_feed', { id }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Refresh all feeds
   */
  async refreshAllFeeds(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('refresh_all_feeds') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Create a new feed
   */
  async createFeed(feedUrl: string, categoryId: string | null): Promise<Result<string, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('create_feed', { feedUrl, categoryId }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Update a feed
   */
  async updateFeed(id: string, updates: FeedUpdate): Promise<Result<Feed, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('update_feed', { id, updates }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Delete a feed
   */
  async deleteFeed(id: string): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('delete_feed', { id }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Get current user
   */
  async getCurrentUser(): Promise<Result<User, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_current_user') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Get counters
   */
  async getCounters(): Promise<Result<Counters, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_counters') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Discover subscriptions from URL
   */
  async discoverSubscriptions(url: string): Promise<Result<Subscription[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('discover_subscriptions', { url }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Export OPML
   */
  async exportOpml(): Promise<Result<string, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('export_opml') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Import OPML
   */
  async importOpml(opmlContent: string): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('import_opml', { opmlContent }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Fetch original article content
   */
  async fetchEntryContent(id: string, updateContent: boolean): Promise<Result<string, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('fetch_entry_content', { id, updateContent }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async syncMiniflux(): Promise<Result<SyncSummary, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('sync_miniflux') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Get unread counts from local database
   */
  async getUnreadCounts(): Promise<Result<UnreadCounts, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_unread_counts') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
};

/** user-defined events **/

/** user-defined constants **/

/** user-defined types **/

/**
 * Error types for account operations
 */
export type AccountError =
  /**
   * Credentials not found in keyring
   */
  | { type: 'NotFound' }
  /**
   * Invalid credentials provided
   */
  | { type: 'InvalidCredentials' }
  /**
   * Keyring operation failed
   */
  | { type: 'KeyringError'; data: { message: string } }
  /**
   * Database operation failed
   */
  | { type: 'DatabaseError'; data: string };
/**
 * Application preferences that persist to disk.
 * Only contains settings that should be saved between sessions.
 */
export type AppPreferences = {
  theme: string;
  /**
   * Global shortcut for quick pane (e.g., "CommandOrControl+Shift+.")
   * If None, uses to default shortcut
   */
  quick_pane_shortcut: string | null;
  /**
   * User's preferred language (e.g., "en", "es", "de")
   * If None, uses system locale detection
   */
  language: string | null;
  /**
   * Behavior when window close button is clicked
   */
  close_behavior: CloseBehavior;
  /**
   * Whether to show tray icon
   */
  show_tray_icon: boolean;
  /**
   * Whether to start minimized to tray
   */
  start_minimized: boolean;
  /**
   * Reader font size (14-24)
   */
  reader_font_size: number;
  /**
   * Reader line width (45-80)
   */
  reader_line_width: number;
  /**
   * Reader font family (sans-serif, serif, monospace)
   */
  reader_font_family: string;
  /**
   * Reader code block syntax highlight theme.
   */
  reader_code_theme: string;
  /**
   * Chinese conversion mode for reading content.
   */
  reader_chinese_conversion: ChineseConversionMode;
  /**
   * Enable bionic reading emphasis for English text.
   */
  reader_bionic_reading: boolean;
  /**
   * User-defined term conversion rules applied after Chinese conversion.
   */
  reader_custom_conversions?: ChineseConversionRule[];
  /**
   * Default download path for images (null = ask every time)
   */
  image_download_path: string | null;
  /**
   * Default download path for videos (null = ask every time)
   */
  video_download_path: string | null;
};
/**
 * Authentication Config
 */
export type AuthConfig = {
  server_url: string;
  auth_token?: string | null;
  username?: string | null;
  password?: string | null;
};
/**
 * Miniflux Category
 */
export type Category = {
  id: string;
  user_id: string;
  title: string;
  hide_globally?: boolean;
  created_at?: string | null;
  updated_at?: string | null;
};
/**
 * Per-category unread count
 */
export type CategoryUnread = { category_id: string; unread_count: string };
/**
 * Chinese conversion mode for the reading panel.
 */
export type ChineseConversionMode =
  /**
   * Keep source content unchanged.
   */
  | 'off'
  /**
   * Convert Simplified Chinese to Traditional Chinese (Taiwan).
   */
  | 's2tw'
  /**
   * Convert Simplified Chinese to Traditional Chinese (Hong Kong).
   */
  | 's2hk'
  /**
   * Convert Traditional Chinese to Simplified Chinese.
   */
  | 't2s';
/**
 * Custom rule for Chinese term conversion.
 */
export type ChineseConversionRule = {
  /**
   * Source term to match.
   */
  from: string;
  /**
   * Replacement term to apply.
   */
  to: string;
};
/**
 * Window close behavior options
 */
export type CloseBehavior =
  /**
   * Quit the application completely
   */
  | 'quit'
  /**
   * Minimize to tray (hide window, keep running)
   */
  | 'minimize_to_tray';
/**
 * Counters
 */
export type Counters = { user_id: string; read_count: string; unread_count: string };
/**
 * Download state managed by download manager
 */
export type DownloadState =
  /**
   * Download is in progress
   */
  | {
      Downloading: {
        id: string;
        url: string;
        progress: number;
        downloaded_bytes: string;
        total_bytes: string;
        started_at: SystemTime;
      };
    }
  /**
   * Download completed successfully
   */
  | {
      Completed: {
        id: string;
        url: string;
        file_path: string;
        total_bytes: string;
        progress: number;
        completed_at: SystemTime;
      };
    }
  /**
   * Download failed
   */
  | { Failed: { id: string; url: string; error: string; progress: number; failed_at: SystemTime } }
  /**
   * Download was cancelled
   */
  | { Cancelled: { id: string; url: string; progress: number; cancelled_at: SystemTime } };
/**
 * Enclosure (for podcasts/videos)
 */
export type Enclosure = {
  id: string;
  entry_id: string;
  url: string;
  mime_type: string;
  length?: string | null;
  position?: number;
};
/**
 * Miniflux Entry
 */
export type Entry = {
  id: string;
  user_id: string;
  feed_id: string;
  title: string;
  url: string;
  comments_url?: string | null;
  author?: string | null;
  content?: string | null;
  hash: string;
  published_at: string;
  created_at?: string | null;
  changed_at?: string | null;
  status: string;
  share_code?: string | null;
  starred?: boolean;
  reading_time?: number | null;
  enclosures?: Enclosure[] | null;
  feed: Feed;
  tags?: string[] | null;
};
/**
 * Entry Filters
 */
export type EntryFilters = {
  status?: string | null;
  offset?: string | null;
  limit?: string | null;
  order?: string | null;
  direction?: string | null;
  before?: string | null;
  after?: string | null;
  published_before?: string | null;
  published_after?: string | null;
  changed_before?: string | null;
  changed_after?: string | null;
  before_entry_id?: string | null;
  after_entry_id?: string | null;
  starred?: boolean | null;
  search?: string | null;
  category_id?: string | null;
  feed_id?: string | null;
  globally_visible?: boolean | null;
};
/**
 * Entry Response (with pagination)
 */
export type EntryResponse = { total: string; entries?: Entry[] | null };
/**
 * Entry Update
 */
export type EntryUpdate = { title?: string | null; content?: string | null };
/**
 * Miniflux Feed
 */
export type Feed = {
  id: string;
  user_id: string;
  title: string;
  site_url: string;
  feed_url: string;
  category: Category | null;
  icon: FeedIcon | null;
  checked_at?: string | null;
  etag_header?: string | null;
  last_modified_header?: string | null;
  parsing_error_message?: string | null;
  parsing_error_count?: number;
  scraper_rules?: string | null;
  rewrite_rules?: string | null;
  crawler?: boolean;
  blocklist_rules?: string | null;
  keeplist_rules?: string | null;
  user_agent?: string | null;
  username?: string | null;
  password?: string | null;
  disabled?: boolean;
  ignore_http_cache?: boolean;
  fetch_via_proxy?: boolean;
  no_media_player?: boolean;
  allow_self_signed_certificates?: boolean;
  urlrewrite_rules?: string | null;
  cookie?: string | null;
  apprise_service_urls?: string | null;
  hide_globally?: boolean;
  created_at?: string | null;
  updated_at?: string | null;
};
/**
 * Feed Icon
 */
export type FeedIcon = { feed_id: string; icon_id: string };
/**
 * Per-feed unread count
 */
export type FeedUnread = { feed_id: string; unread_count: string };
/**
 * Feed Update
 */
export type FeedUpdate = {
  feed_url?: string | null;
  site_url?: string | null;
  title?: string | null;
  category_id?: string | null;
  scraper_rules?: string | null;
  rewrite_rules?: string | null;
  blocklist_rules?: string | null;
  keeplist_rules?: string | null;
  crawler?: boolean | null;
  user_agent?: string | null;
  username?: string | null;
  password?: string | null;
  disabled?: boolean | null;
  ignore_http_cache?: boolean | null;
  fetch_via_proxy?: boolean | null;
};
export type JsonValue =
  | null
  | boolean
  | number
  | string
  | JsonValue[]
  | Partial<{ [key in string]: JsonValue }>;
export type LastReadingEntry = { entry_id: string; timestamp: string };
export type MinifluxConnection = {
  id: string;
  username: string;
  server_url: string;
  auth_method: string;
  is_active: boolean;
  created_at: string;
  updated_at: string;
};
/**
 * Error types for recovery operations (typed for frontend matching)
 */
export type RecoveryError =
  /**
   * File does not exist (expected case, not a failure)
   */
  | { type: 'FileNotFound' }
  /**
   * Filename validation failed
   */
  | { type: 'ValidationError'; message: string }
  /**
   * Data exceeds size limit
   */
  | { type: 'DataTooLarge'; max_bytes: number }
  /**
   * File system read/write error
   */
  | { type: 'IoError'; message: string }
  /**
   * JSON serialization/deserialization error
   */
  | { type: 'ParseError'; message: string };
/**
 * Subscription (from discover)
 */
export type Subscription = { url: string; title: string; type: string };
export type SyncSummary = {
  entries_pulled: number;
  entries_pushed: number;
  feeds_pulled: number;
  categories_pulled: number;
};
export type SystemTime = { duration_since_epoch: string; duration_since_unix_epoch: number };
/**
 * Tray icon states for visual feedback
 */
export type TrayIconState =
  /**
   * Normal/default state
   */
  | 'normal'
  /**
   * Notification badge (red dot)
   */
  | 'notification'
  /**
   * Urgent/animated alert state
   */
  | 'alert';
/**
 * Enhanced unread counts from local database
 */
export type UnreadCounts = {
  total: string;
  by_category: CategoryUnread[];
  by_feed: FeedUnread[];
  today: string;
};
/**
 * User
 */
export type User = {
  id: string;
  username: string;
  is_admin?: boolean;
  theme?: string | null;
  language?: string | null;
  timezone?: string | null;
  entry_sorting_direction?: string | null;
  entry_sorting_order?: string | null;
  entries_per_page?: number | null;
  keyboard_shortcuts?: boolean | null;
  display_mode?: string | null;
  show_reading_time?: boolean | null;
  entry_swipe?: boolean | null;
  stylesheet?: string | null;
  google_id?: string | null;
  openid_connect_id?: string | null;
  last_login_at?: string | null;
  created_at?: string | null;
  updated_at?: string | null;
};

/** tauri-specta globals **/

import { Channel as TAURI_CHANNEL, invoke as TAURI_INVOKE } from '@tauri-apps/api/core';
import * as TAURI_API_EVENT from '@tauri-apps/api/event';
import type { WebviewWindow as __WebviewWindow__ } from '@tauri-apps/api/webviewWindow';

type __EventObj__<T> = {
  listen: (cb: TAURI_API_EVENT.EventCallback<T>) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
  once: (cb: TAURI_API_EVENT.EventCallback<T>) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
  emit: null extends T
    ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
    : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> = { status: 'ok'; data: T } | { status: 'error'; error: E };

function __makeEvents__<T extends Record<string, any>>(mappings: Record<keyof T, string>) {
  return new Proxy(
    {} as unknown as {
      [K in keyof T]: __EventObj__<T[K]> & ((handle: __WebviewWindow__) => __EventObj__<T[K]>);
    },
    {
      get: (_, event) => {
        const name = mappings[event as keyof T];

        return new Proxy((() => {}) as any, {
          apply: (_, __, [window]: [__WebviewWindow__]) => ({
            listen: (arg: any) => window.listen(name, arg),
            once: (arg: any) => window.once(name, arg),
            emit: (arg: any) => window.emit(name, arg),
          }),
          get: (_, command: keyof __EventObj__<any>) => {
            switch (command) {
              case 'listen':
                return (arg: any) => TAURI_API_EVENT.listen(name, arg);
              case 'once':
                return (arg: any) => TAURI_API_EVENT.once(name, arg);
              case 'emit':
                return (arg: any) => TAURI_API_EVENT.emit(name, arg);
            }
          },
        });
      },
    }
  );
}
