// @ts-nocheck
// Auto-generated by tauri-specta. DO NOT EDIT.

// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
  /**
   * Simple greeting command for demonstration purposes.
   */
  async greet(name: string): Promise<Result<string, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('greet', { name }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Loads user preferences from disk.
   * Returns default preferences if the file doesn't exist.
   */
  async loadPreferences(): Promise<Result<AppPreferences, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('load_preferences') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Saves user preferences to disk.
   * Uses atomic write (temp file + rename) to prevent corruption.
   */
  async savePreferences(preferences: AppPreferences): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('save_preferences', { preferences }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Sends a native system notification.
   * On mobile platforms, returns an error as notifications are not yet supported.
   */
  async sendNativeNotification(title: string, body: string | null): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('send_native_notification', { title, body }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Saves emergency data to a JSON file for later recovery.
   * Validates filename and enforces a 10MB size limit.
   */
  async saveEmergencyData(filename: string, data: JsonValue): Promise<Result<null, RecoveryError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('save_emergency_data', { filename, data }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Loads emergency data from a previously saved JSON file.
   * Returns FileNotFound if the file doesn't exist.
   */
  async loadEmergencyData(filename: string): Promise<Result<JsonValue, RecoveryError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('load_emergency_data', { filename }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Removes recovery files older than 7 days.
   * Returns the count of removed files.
   */
  async cleanupOldRecoveryFiles(): Promise<Result<number, RecoveryError>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('cleanup_old_recovery_files') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Shows the quick pane window and makes it the key window (for keyboard input).
   */
  async showQuickPane(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('show_quick_pane') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Dismisses the quick pane window.
   * On macOS, resigns key window status before hiding to avoid activating main window.
   */
  async dismissQuickPane(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('dismiss_quick_pane') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Toggles the quick pane window visibility.
   */
  async toggleQuickPane(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('toggle_quick_pane') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Returns the default shortcut constant for frontend use.
   */
  async getDefaultQuickPaneShortcut(): Promise<string> {
    return await TAURI_INVOKE('get_default_quick_pane_shortcut');
  },
  /**
   * Updates the global shortcut for the quick pane.
   * Pass None to reset to default.
   */
  async updateQuickPaneShortcut(shortcut: string | null): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('update_quick_pane_shortcut', { shortcut }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Show the main window (command exposed to frontend)
   */
  async trayShowWindow(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('tray_show_window') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Hide the main window (command exposed to frontend)
   */
  async trayHideWindow(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('tray_hide_window') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Toggle main window visibility (command exposed to frontend)
   */
  async trayToggleWindow(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('tray_toggle_window') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Update the tray icon state
   */
  async traySetIconState(state: TrayIconState): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('tray_set_icon_state', { state }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Update the tray tooltip
   */
  async traySetTooltip(tooltip: string): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('tray_set_tooltip', { tooltip }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Get the current tray icon state
   */
  async trayGetState(): Promise<TrayIconState> {
    return await TAURI_INVOKE('tray_get_state');
  },
  /**
   * Check if the main window is visible
   */
  async trayIsWindowVisible(): Promise<Result<boolean, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('tray_is_window_visible') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
};

/** user-defined events **/

/** user-defined constants **/

/** user-defined types **/

/**
 * Application preferences that persist to disk.
 * Only contains settings that should be saved between sessions.
 */
export type AppPreferences = {
  theme: string;
  /**
   * Global shortcut for quick pane (e.g., "CommandOrControl+Shift+.")
   * If None, uses the default shortcut
   */
  quick_pane_shortcut: string | null;
  /**
   * User's preferred language (e.g., "en", "es", "de")
   * If None, uses system locale detection
   */
  language: string | null;
  /**
   * Behavior when window close button is clicked
   */
  close_behavior: CloseBehavior;
  /**
   * Whether to show the tray icon
   */
  show_tray_icon: boolean;
  /**
   * Whether to start minimized to tray
   */
  start_minimized: boolean;
};
/**
 * Window close behavior options
 */
export type CloseBehavior =
  /**
   * Quit the application completely
   */
  | 'quit'
  /**
   * Minimize to tray (hide window, keep running)
   */
  | 'minimize_to_tray';
export type JsonValue =
  | null
  | boolean
  | number
  | string
  | JsonValue[]
  | Partial<{ [key in string]: JsonValue }>;
/**
 * Error types for recovery operations (typed for frontend matching)
 */
export type RecoveryError =
  /**
   * File does not exist (expected case, not a failure)
   */
  | { type: 'FileNotFound' }
  /**
   * Filename validation failed
   */
  | { type: 'ValidationError'; message: string }
  /**
   * Data exceeds size limit
   */
  | { type: 'DataTooLarge'; max_bytes: number }
  /**
   * File system read/write error
   */
  | { type: 'IoError'; message: string }
  /**
   * JSON serialization/deserialization error
   */
  | { type: 'ParseError'; message: string };
/**
 * Tray icon states for visual feedback
 */
export type TrayIconState =
  /**
   * Normal/default state
   */
  | 'normal'
  /**
   * Notification badge (red dot)
   */
  | 'notification'
  /**
   * Urgent/animated alert state
   */
  | 'alert';

/** tauri-specta globals **/

import { invoke as TAURI_INVOKE } from '@tauri-apps/api/core';
import * as TauriApiEvent from '@tauri-apps/api/event';
import type { WebviewWindow as __WebviewWindow__ } from '@tauri-apps/api/webviewWindow';

type __EventObj__<T> = {
  listen: (cb: TauriApiEvent.EventCallback<T>) => ReturnType<typeof TauriApiEvent.listen<T>>;
  once: (cb: TauriApiEvent.EventCallback<T>) => ReturnType<typeof TauriApiEvent.once<T>>;
  emit: null extends T
    ? (payload?: T) => ReturnType<typeof TauriApiEvent.emit>
    : (payload: T) => ReturnType<typeof TauriApiEvent.emit>;
};

export type Result<T, E> = { status: 'ok'; data: T } | { status: 'error'; error: E };

function __makeEvents__<T extends Record<string, any>>(mappings: Record<keyof T, string>) {
  return new Proxy(
    {} as unknown as {
      [K in keyof T]: __EventObj__<T[K]> & ((handle: __WebviewWindow__) => __EventObj__<T[K]>);
    },
    {
      get: (_, event) => {
        const name = mappings[event as keyof T];

        return new Proxy((() => {}) as any, {
          apply: (_, __, [window]: [__WebviewWindow__]) => ({
            listen: (arg: any) => window.listen(name, arg),
            once: (arg: any) => window.once(name, arg),
            emit: (arg: any) => window.emit(name, arg),
          }),
          get: (_, command: keyof __EventObj__<any>) => {
            switch (command) {
              case 'listen':
                return (arg: any) => TauriApiEvent.listen(name, arg);
              case 'once':
                return (arg: any) => TauriApiEvent.once(name, arg);
              case 'emit':
                return (arg: any) => TauriApiEvent.emit(name, arg);
            }
          },
        });
      },
    }
  );
}
